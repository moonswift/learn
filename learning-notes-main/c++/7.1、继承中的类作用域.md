#### 继承中的类作用域

每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，**派生类的作用域嵌套在其基类的作用域之内**。**如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。**派生类的作用域位于基类作用域之内这一事实可 能有点儿出人意料，毕竟在我们的程.序文本中派生类和基类的定义是相互分离开来的。不过也恰恰因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员。例如，当我们编写下面的代码时:

```c++
Bulk_quote bulk;//假设 继承自Disc_quote  <-- Quote
cout << bulk.isbn () ;

/*
名字isbn的解析将按照下述过程所示:
1 因为我们是通过Bulk_quote 的对象调用isbn的，所以首先在Bulk_quote 中查找，这一步没有找到名字isbn.
●因为Bulk_quote是Disc_quote的派生类，所以接下来在Disc_quote中查找，仍然找不到。
●因为Disc_quote是Quote的派生类，所以接着查找Quote; 此时找到了名字isbn，所以我们使用的isbn最终被解析为Quote中isbn.
*/
```



- 名字冲突与继承

和其他作用域一样， 派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域(即派生类)的名字将**隐藏**定义在外层作用域(即基类)的名字

```c++
struct Base 
{
    Base():mem(0) { }
protected:
    int mem;
};
struct Derived : Base {
    Derived(int i) : mem(i) { }
    int get_mem() { return mem;}
protected:
    int mem;//隐藏
};
//派生的mem 隐藏了基类的mem
```

- 通过作用域符号访问隐藏成员

```c++
struct Derived : Base {
int get_base_mem() { return Base::mem; }
};
```

**原则：除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。**



```text
关键概念:名字查找与继承
理解函数调用的解析过程对于理解C++的继承至关重要，假定我们调用p->mem()(或者obj.mem() )，则依次执行以下4个步骤:
1 首先确定p(或obj)的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。
2 在p(或obj)的静态类型对应的类中查找mem。。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。
3 一旦找到了mem,就进行常规的类型检查以确认对于当前找到的mem,本次调用是否合法。
4 假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码:
---如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。
---反之，如果mem不是虚函数或者我们是通过对象(而非引用或指针)进行的调用，则编译器将产生一个常规函数调用。
```

