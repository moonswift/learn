## ARM体系结构 

##### 课程安排： 3 (基础理论，arm汇编指令) + 4（裸机编程）

##### 课程特点：软硬结合，（硬件的基础知识，arm汇编， 裸机编程，芯片手册）

## 一、理论知识

#### 1.ARM简介	

##### 		1.一个公司      

##### 		2.一系列的芯片

~~~
精简指令集RISC
低功耗
主流的产品线，A系列，R系列，M系列
~~~

##### 		3.ARM开发技术



#### 2.工作模式 （经典模型 7 种工作模式）

| 模式       | 简介                                               |
| ---------- | -------------------------------------------------- |
| User       | 非特权模式，大部分任务执行在这种模式               |
| FIQ        | 当一个高优先级（fast) 中断产生时将会进入这种模式   |
| IRQ        | 当一个低优先级（normal) 中断产生时将会进入这种模式 |
| Supervisor | 当复位或软中断指令执行时将会进入这种模式           |
| Abort      | 当存取异常时将会进入这种模式                       |
| Undef      | 当执行未定义指令时会进入这种模式                   |
| System     | 使用和User模式相同寄存器集的特权模式               |

Cortex-A特有模式：
	Monitor : 是为了安全而扩展出的用于执行安全监控代码的模式； 
     也是一种特权模式

#### 3.寄存器

##### 经典模型 37个寄存器

##### 		1 个用作PC( program counter)          

##### 		1个用作CPSR(current program status register)

##### 		5个用作SPSR(saved program status registers)

##### 		30 个通用寄存器 

##### A系列： 40（37+3 ) 

~~~
R15(PC)  : 程序计数器
R14(LR)  : 链接寄存器， 记录pc值，用于返回
R13(SP)  : 栈顶指针
~~~

## 二、环境搭建



## 作业

~~~
1.练习arm汇编指令，尝试模式切换svc->irq, irq->user

2.cpu， soc， mcu，是什么？
cpu(central processing unit)， 中央处理器
soc(System on a Chip),片上系统（cpu+各种控制器，集成度更高）
mcu(Microcontroller Unit),微控制器（性能更弱，侧重于做控制）
~~~



## 三、ARM汇编指令

~~~cpp
//空指令
nop
nop

//传输指令
MOV   R1,0b0111 @R1=7 
MOV   R1,#3     @R1=3
MOV   R1,#0x17  @R1=0x17
MOV   R0,R1     @R0=R1
MVN   R0,R1     @R0=~R1

//算术指令
ADD R0,R1,R2    @R0=R1+R2
    //ADD  不带进位的加法
    //ADDS 带进位的加法，进位时反映到CPSR中C位
    //ADDC 带进位的加法，加运算时，加上CPSR中的C位
    
SUB  R0,R1,#3   @R0= R1 - 3
MUL  R1,R2,r3   @R1=R2*r3
ADD  R0,#1      @R0=R0+1


//移位指令
//LSL逻辑移位
//ASL算术移位

MOV R0,R1,LSL#2   @R0=R1<<2
MOV R2,R1,LSR#1   @R2=R1>>1
ADD R2,R0,LSL#1   @R2 = R2 + R0<<1
    

//跳转
 B   label        //跳转到label标签 
 B    main        //跳转到标号为main地代码处 
 BL   func        //保存下一条要执行的指令的位置到 LR寄存器,跳转函数func
                  ///当跳转代码结束后,用MOV PC,LR返回

//CPSR访问指令(mrs msr)
MRS R0,CPSR  @ R0 = CPSR
MSR CPSR,R0  @ CPSR = R0
    
    
//位运算 AND ORR BIC TST
    
AND R0,R1,#0xFF   // r0 = r1&0xFF
ORR R3,R0,#0x0F   // r3 = r0|0x0F
BIC R0,R0,#0x03   // 清除r0中的0号位和1号位
TST R0,#0x20      //测试第5位是否为0 ，为0则CPSR,Z标志置1
//配合着条件码使用

//比较指令      
 CMP r0,r1,       // 比较R0与R1的值
//注意：比较结果反映在CPSR中的N z c位
//配合着条件码使用

//练习
//1.测试当前工作状态是否是ARM, 是的话 r5=0xff
MRS R0,CPSR
TST R0,#0X20
MOVEQ R5,#0XFF
//2.修改当前的工作模式，切换到user模式
MRS R0,CPSR
BIC R0,#0X1F
ORR R0,#0X10
MSR CPSR,R0
  
//load/store指令
LDR R0,[R1]  @ R0 = *R1
//LDR 读4字节  LDRH 读2字节  LDRB 读1字节
STR R0,[R1]  @ *R1 = R0

//stmfd/ldmfd 
//入栈：stmfd	sp!,{r0-r12}  @以sp作为栈顶指针
//退栈：ldmfd 	sp!,{r0-r12}
例如：
 stmfd sp!,{r0-r12,lr}   将寄存器r0~r12 lr中的值存入栈中   
                                // 常用于中断保护现场,! 表示会自动偏移                         
 ldmfd sp!,{r0-r12,pc}^  将栈中值逐个弹出到寄存器r0~r12 pc中  (lr恢复pc)
                               //  常用于中恢复断现场，^表示会恢复spsr到cpsr
    
 //软中断指令 swi
   swi 0x02  产生软中断， 软中断号为2


 gun伪指令
.text                     		将定义符开始的代码编译到代码段
.data                    	 	将定义符开始的代码编译到数据段
.end                      		文件结束
.global 符号		将符号声明位全局符号；
.byte			 单字节定义		.byte	0x12,’a’,23
.long /.word     定义4字节数据	.word	0x12345678

    
~~~



## 四、立即数合法性分析

~~~c++
//在32位arm架构下
//arm指令占32bit位，其中立即数所占bit位12位(4位移位数，8位基数)

//合法的立即数，必须能够分解成（移位数占4位+基数占8位）
//1.满足基数，<=8bit位
//2.满足移位数是偶数（通过基数循环右移 移位数*2 ）

例如：0xF000000F,可以通过 基数(0xff) +移位数(2) 得到
//                        0xff 循环向右移动2*2 即可得到0xF000000F
例如：0x00001f80，可以通过 基数(0x7E) +移位数(13)得到
//                        0x7E 循环向右移动13*2即可得到0x00001f80
    
//通过LDR可以避免立即数合法性问题
LDR R0,=0x08000012   //为了避免立即数不合法，可以通过LDR实现 大数据的赋值
LDR R0,=0XFFFF 
LDR R1,=0x08000012
LDR R2,=0x001f70 
 
~~~



## 作业

~~~c
1.练习：汇编指令

2.试分析下面的数是否是合法的立即数
b) 0x08000012 
	0000 1000 0000 0000 0000 0000 0001 0010    //基数不满足条件
c) 0x001f70   
    0000 0000 0001 1111 0111 0000              //基数不满足条件    
d) 0x7000000f 
    0111 0000 0000 0000 0000 0000 0000 1111    //ok
                                               //基数 1111 0111 
    										   //循环右移4位

~~~



## 五、流水线分析

~~~
以三级流水线分析
指令分为3个阶段：取指–>译码–>执行，
第一阶段持有从内存中取回的指令。
第二阶段开始解码
第三阶段实际执行它。 （因此pc值是当前指令+8，已经在对后面的指令进行取指令操作了）
所以在分支，以及中断中，流水线作业将会被打断。
~~~



## 六、异常

#### 6.1异常源

| 地址偏移量 | 异常源       | 描述                                                         |
| :--------- | ------------ | ------------------------------------------------------------ |
| 0x00000000 | 复位         | 复位电平有效时，产生复位异常，程序跳转到复位处理程序处执行   |
| 0x00000004 | 未定义指令   | 遇到不能处理的指令时，产生未定义指令异常                     |
| 0x00000008 | 软中断       | 执行SWI指令产生，用于用户模式下的程序调用特权操作指令        |
| 0x0000000C | 预取指令异常 | 处理器预取指令的地址不存在，或该地址不允许当前指令访问，产生 指令预取中止异常 |
| 0x00000010 | 数据异常     | 处理器数据访问指令的地址不存在，或该地址不允许当前指令访问 时 产生数据中止异常 |
| 0x00000014 | 保留         | 保留                                                         |
| 0x00000018 | IRQ          | 外部中断请求有效，且CPSR中的I位为0时，产生IRQ异常            |
| 0x0000001C | FIQ          | 快速中断请求引脚有效，且CPSR中的F位为0时，产生FIQ异常        |

#### 6.2 异常与工作模式对应关系

​	复位异常	  -->   SVC模式
​	未定义异常  -->   Undef
​	软中断异常  -->   SVC模式
​	预取指异常  -->   abort
​	数据异常	  -->   abort
​	IRQ异常	   -->   IRQ模式
​	FIQ异常		-->  FIQ模式

#### 6.3异常优先级

多个异常可以在同一时间产生，通过优先级决定先处理哪个异常

​	Reset
​	Data Abort
​	FIQ
​	IRQ
​	Prefetch Abort
​	SWI
​	Undefined instruction  

#### 6.4异常处理机制（软中断）

~~~
硬件自动完成：
1、R14_< exception_mode > = return link  //记录返回地址
2、SPSR_< exception_mode > = CPSR 		//记录状态
    
3、修改CPSR相应的位 （切换到对应的模式）
（1）CPSR[4:0] = exception mode number //切换到相应异常的工作模式
（2）CPSR[5] = 0 ; 					 //进入ARM状态（都会进入到arm状态）
（3）If ==Reset or Fiq then 			 //只有在复位和FIQ模式下才会关闭FIQ中断
 CPSR[6] = 1 ;                        //任何异常模式下都会关闭IRQ中断

4、pc = exception vector address     //对应的异常向量表入口处

用户编程完成：
1、设置异常向量表

2、编写中断服务器程序
   	保护现场
    中断处理
    恢复现场
~~~

#### 6.5C与汇编混合编程

~~~c
汇编调用c代码注意 传参规则，根据ATPCS规定，默认使用r0-r3传递参数，如果需要更多的参数，将使用堆栈  
C调用汇编，注意汇编标号，需要声明为global
C调用汇编，还可以采用内联汇编 
//例如，在c代码中嵌入
asm ("mov r0, #2\n\t"
	          "mov r1, #3\n\t"
	         "add r2, r1, r0\n\t"
	)；
~~~

~~~c
练习
1.汇编指令
2.预习异常处理
~~~

