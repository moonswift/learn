数组指针: 本质上是一个指针，只不过这个指针指向的是整个数组
	一般形式:
	<存储类型> <数据类型> (*指针名)[下标];
	char (*p)[3];   //下标代表该指针可以指向具备该下标这么多个元素的数组
	
	int a[4] = {1,2,3,4}， b[4] = {4,3,2,1};
	int (*p)[4] = &a;
	
	p = &b; 
	数组指针去遍历一个一维数组:
	for(int i = 0; i < 4; i++)
		printf("%d ", (*p)[i]); // *p == *&b --> *p == b  -->  (*p)[i] == b[i]
	
	注意：
		对一维数组的数组名取地址表示整个一维数组的地址
		
	数组指针指向二维数组:
	int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
	int (*p)[4];
	p = a;
	数组指针遍历整个二维数组:
	for(int i = 0; i < 3; i++){
		for(int j = 0; j < 4; j++)
			printf("%d ", (*(p+i))[j]);  //p[i][j] *(*(p+i)+j)
		puts("");
	}
	
指针数组: 本质是一个数组，只不过这个数组里面每一个元素都是指针
	一般形式:
	<存储类型> <数据类型> *数组名[下标];
	int *a[3];   //代表数组a中有3个int *的指针
	
	int a = 10, b = 20, c = 30;
	int *arr[3] = {&a, &b, &c};
	*arr[0]  == a  == 10;
	
	char a[100] = "one", b[100] = "world!", c[100] = "welcome";
	char *arr[3] = {a, b, c};
	*(arr[0]+1) == a[1] == 'n';
	*arr[0] = 'N'; //OK  a[0] = 'N';
	
	char *p = "hello";
	
	char *arry[4] = {"abc", "defg", "bbbbb", "cccccc"};
	puts(arry[0]);
	*(arry[0]+1) == 'b';
	//*arry[0] = 'A'; //err
	
	练习:
		根据字符指针数组里每个字符串的长度进行排序.
		
	和二维数组建立联系:
	int a[2][3] = {1,2,3,4,5,6};
	int *arr[2] = {a[0], a[1]};
	遍历:
	for(int i = 0; i < 2; i++){
		for(int j = 0; j < 3; j++)
			printf("%d ", *(arr[i]+j));  //arr[i][j]   *(*(arr+i)+j)  (*(arr+i))[j]
		puts("");
	}
	
	练习:
		通过指针数组计算对应二维数组所有元素的累加和
		
函数:
	具有特定功能的代码模块
	
	一般形式:
	<存储类型> <数据类型> 函数名(形式参数列表)
	{
		函数体;
		return;
	}
	
	1、函数的声明
	void ptr(void);  //一般放在文件的开头（main函数之前）
	2、函数调用
	ptr();           //在需要实现对应功能的地方调用函数
	3、函数的实现
	void ptr(void)  //一般在main函数之后
	{
		puts("你睡醒了吗?");
	}
		
	总结:
		当实参不希望被被调函数修改的时候，可以使用函数的参数传递
		当实参希望被被调函数修改的时候，要使用函数参数的地址传递
		
	作业：
		1、根据字符指针数组里每个字符串的长度进行排序.
		
		2、实现一个整型的算术计算器:
		
		3、封装函数mystrcmp实现strcmp的功能
		
		4、封装函数myatoi实现atoi函数的功能.
		
		5、封装一个函数，实现对任意int型数组冒泡排序.
	
	
	
	