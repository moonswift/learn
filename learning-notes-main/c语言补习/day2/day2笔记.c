变量的一般形式:
	<存储类型> <数据类型> <变量名>;
	初始化: 在变量定义时就赋初始值
	赋值:   在定义之后再去给变量一个值
	int a;
	a = 10;	//赋值
	int b = 20; //初始化
	int a = 10, b = 20; //初始化
	a = b;	//赋值
	int a = 10, b = a;   //初始化
	int b = a, a = 10;	 //错误, a未定义
	
强制数据类型的转换是指采用某种方式将某种数据类型强制转换成指定的数据类型。
这种转换存在两种方式：一种为显式的数据类型转换，另一种为隐式的数据类型转换。
	显式的数据类型转换实现的一般形式为：
        （数据类型名称）< 表达式 >
		
在C语言中char和short在参与算术运算时都会自动变为int
char a = 'A'+2
short b = a+2;

=
 int a = (int)(4.9+1.1)
 float b = 3.14;
 int a = (int)b+3;
 b = ?
   
  
算术运算：
	+ - * / % ++ --
	/: 如果左右两边都是整数，它代表的是整除，如果左右两边只要有一个是浮点数，
	   则结果一定是浮点数
	%：它只能用于整数运算，求的是余数
	++:前++表示先自己加1，再参与运算
	   后++表示先参与运算，再加1
	   int a = 10, b;
	   b = ++a;
	   printf("%d %d\n", a, b);  // 11 11
	   int a = 10, b;
	   b = a++;
	   printf("%d %d\n", a, b);  // 11 10
	
	--:同上，只不过加1变成减1
	
逻辑运算符：
	&& || !
	&&:左右两个操作数都为真，结果为真，如果左右操作数有一个或都为假，结果一定为假
	短路法则:
		int a = 0, b = 1, c;
		c = a && ++b;
		printf("%d %d %d\n", a, b, c);  //0 1 0
		
	test:
		int a = 0, b = 1, c;
		c = a++ && ++b;
		printf("%d %d %d\n", a, b, c);
		
		int a = 0, b = 1, c;
		c = ++a && ++b;
		printf("%d %d %d\n", a, b, c);
	
	||：左右两个操作数都为假，结果为假，如果左右操作数有一个或都为真，结果一定为真
		int a = 1, b = 1, c;
		c = a || ++b;
		printf("%d %d %d\n", a, b, c);  //1 1 1
		
	test:
		int a = 1, b = 1, c;
		c = a-- || ++b;
		printf("%d %d %d\n", a, b, c);  //0 1 1
		
		int a = 1, b = 1, c;
		c = --a || ++b;
		printf("%d %d %d\n", a, b, c);  //0 2 1
		
	!:操作数为真结果为假，操作数为假结果为真
	int a = 0, c;
	c = !a;
	
位运算:
	& | ~ ^ << >>
	&:位与,双目运算符，左右操作数按位进行与操作
		char a = 0x10, b = 071, c;
		c = a & b;
		  = 1 0000 & 11 1001
		  = 01 0000 & 11 1001
		  = 01 0000
		  = 0x10
	|:位或,双目运算符，左右操作数按位进行或操作
		char a = 20, b = 66, c;
		c = a | b;
          = 1 0100 | 1000010
          = 001 0100 | 100 0010
          = 101 0110
          = 64+16+4+2
          = 86
    ~:位反,单目运算符,把操作数按位取反
	    char a = 77, c;
		c = ~a;
		  = ~(64+8+4+1)
		  = ~1001101
		  = 0110010
		  = 32+16+2
		  = 50
	^：异或,双目运算符，左右操作数按位进行异或（相同为0不同为1）操作
		char a = 14, b = 51, c;
		c = a ^ b;
		  = 1110 ^ 110011
		  = 00 1110 ^ 11 0011
		  = 11 1101
		  = 32+16+8+4+1
		  = 61
	    test:
			//只能针对整数
			int a = 3, b = 4;	
			a ^= b -> a = a ^ b -> a = 011 ^ 100 -> a = 111
			b ^= a -> b = b ^ a -> b = 111 ^ 100 -> b = 011 -> b = 3
			a ^= b -> a = a ^ b -> a = 111 ^ 011 -> a = 100 -> a = 4
			
			a = a + b;
			b = a - b;
			a = a - b;
			
	<<:左移,双目运算符,把左操作数向左移动右操作数这么多位
		unsigned char a = 151, c;
		c = a << 3;
		  = (128+16+4+2+1) << 3
		  = 1001 0111 << 3
		  = 1011 1000
		  
	>>:右移,双目运算符,把左操作数向右移动右操作数这么多位
		unsigned char a = 151, c;
		c = a >> 3;
		  = (128+16+4+2+1) >> 3
		  = 1001 0111 >> 3
		  = 0001 0010	
	注意：
		移位操作时，目标数据本身不会发生改变
		
	有符号移位:
		符号位不变，看目标数据的正负，
	正数:
		0111 1111 << 1 -> 0111 1110
		0111 1111 >> 1 -> 0011 1111
	负数:
		1000 1111 << 1 -> 1001 1110
		1000 1111 >> 1 -> 1100 0111
		
	思考：
		如何把某个变量低4位快速清0？
		char a;
		a & 0xf0; //a & (~(0xf))
		[20:23]
		b & (~(0xf << 20))
		如何把某个变量高4位快速置1？
		char a;
		a | 0xf0;
		[20:23]
		b | (0xf << 20)
		
复合赋值运算符:
	int a = 3;
	a *= 3+2;
	a = a * (3 + 2)
	
	sizeof int
	
标准输入和输出函数:
	字符输出函数:
		putchar('A');
		putchar(65);
		成功返回打印字符的ASCII失败返回-1
		
	字符串输出函数:
		puts();
		参数要求是字符串的起始地址;
		输出参数代表的字符串遇到'\0'停止,会在输出结束后自动添加'\n'
		返回值代表实际输出的元素个数(包含'\0')
		
	格式化输出函数:
		printf();
		不定参数的函数
		
	格式控制符和修饰符需要大家记忆
	
	字符输入:
		getchar();
		无参数
		从标准输入中获取一个字符，并通过返回值返回其ASCII
		阻塞的函数
	
	字符串输入:
		gets();
		char a[100];
		gets(a);
		
	格式化输入函数:
		scanf();
		结束标志: 空格 回车 tab
		解决脏字符方法:
		getchar()
		%*c
		
	ctrl+d:表示结束输入

作业:
	 1、int a = 1, b = 2, c = 0, d;
	    d = a++ || c++ && ++b;
		a、b、c、d分别是？
		
	 2、char a = -1, c;
		c = a >> 1;
		printf("%d %d\n", a, c);
		输出结果是?
		
	 3、int a = 0x20a1;将a的第4到7位清0,写出表达式.
	 
	 4、short a = 32767; a++; printf("%d\n", a);输出结果是？
	 
	 5、编写程序实现如下功能：
			pleaes input Y|N:
			输入'Y'打印字符"OK"，输入'N'打印字符"NO".
			
	 6、有如下程序
	 int main()
	 {
		char a = 1;
		while(a++);
	 }
	 该程序是不是死循环?
	 
	 *7、int i = 10;printf("%d %d %d\n", i, ++i, i++);输出结果是?
	 本题仔细思考！！！

		
		

	