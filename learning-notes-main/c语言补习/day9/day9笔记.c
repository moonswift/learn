函数参数是一维数组:
	也分为值传递和地址传递(本质上都是地址的传递，所以不能通过sizeof(数组名)/sizeof(数组某个元素)来计
	算数组元素的个数)
	void fun(int a[], int n);
	void fun(int *a, int n);
	
	在给函数传递字符串时，只需要传递首地址（字符串末尾有'\0'）
	函数中定义的变量它的作用域在函数内部，生命周期开始于函数调用，结束于函数调用结束
	
函数参数是二维数组时:
	void fun(int n, int m, int a[][n]);   
	void fun(int n, int m, int (*a)[n]);
	//void fun(int n, int m, int **a);   //**a是二级指针 传值时不能传递二维数组
	
二级指针:
	指向指针的指针
	一个二级指针变量可以存放一级指针的地址
	一般形式：
	<数据类型> **二级指针名;
	int **p;
	
	int a = 10; 
	int *pa = &a;
	int **pp;
	pp = &pa;
	
	pp == &a  --> *pp == *&pa == pa == &a --> **pp == **&pa == *pa == *&a == a
	
	二级指针和二维数组的关系?
	没有关系!!!

指针函数:
	本质上是一个函数，只不过返回值是一个指针
	一般形式:
	<数据类型> *<函数名>(形参列表)
	{
		函数体;
		return 地址;
	}
	不能返回局部变量的地址
	
	注意:
		函数的地址就是函数名
函数指针:
	本质上是一个指针，只不过这个指针指向的是一个函数
	一般形式:
	<数据类型> (*<函数指针名>)(形参列表);
	int add(int a, int b);
	int (*p)(int, int);   //p就是一个指向返回值为int且参数有两个int类型的函数
	
static:
	1、延长变量的生命周期;
	2、限制作用域;
	3、修饰的变量只能被初始化1次
	4、修饰的变量如果没有初始化，会被自动初始化0
	
const ：常量化关键字
	const int a = 10;   //修饰变量时表示这个为只读（常量化）
	
	
	int val1 = 10, val2 = 20;
	const int *p = &val1;  	//常量化指针，不能通过该指针去修改指向空间的内容
	p = &val2			   	//但是可以修改指向
	int const *q = &val1;  	//同上
	
	int * const po = &val1; //指针的指向不可以发生改变，但是可以通过该指针修改对应空的内容
	
	//指向和内容都不允许修改
	const int *const pp = &val1; 
	
void *:
	代表任意类型的指针，不支持+、-
	
	
	